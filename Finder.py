import sys
import socket
import argparse
import threading
import queue
import os
from colorama import Fore, init
from threading import Thread
import random
from datetime import datetime
from urllib.parse import urlparse
from packaging.version import parse as parse_version, InvalidVersion

init()

# ANSI color codes
light_gray_color = Fore.WHITE
dimmed_gray_color = Fore.WHITE
honey_yellow_color = Fore.YELLOW
dim_yellow_color = Fore.YELLOW
cyan_color = Fore.CYAN
green_color = Fore.GREEN
dimmed_green_color = Fore.GREEN
red_color = Fore.RED
light_orange_color = ''
reset_color = Fore.RESET
the_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
LOG_FILE = "scan.log"
the_version ="1.0.4"


def create_log_dir():
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)
        print_message('info', f"Log directory created: {LOG_DIR}")


def log_message(message):
    with open(LOG_FILE, 'a') as log_file:
        log_file.write(f"{the_time} - {message}\n")


def print_message(level, message):
    if level == 'vulnerable':
        print(f"[{light_gray_color}{the_time}] {light_orange_color}[VULN] {message}{reset_color}")
        log_message(message)
    if level == 'info':
        print(f"[{light_gray_color}{the_time}] {dimmed_gray_color}[INFO] {message}{reset_color}")
    elif level == 'ok':
        print(f"[{light_gray_color}{the_time}] {dimmed_green_color}[OK] {message}{reset_color}")
        log_message(message)
    elif level == 'warning':
        print(f"[{light_gray_color}{the_time}] {light_gray_color}[INFO] {message}{reset_color}")
    elif level == 'error':
        print(f"[{light_gray_color}{the_time}] {red_color}[ERROR] {message}{reset_color}")

def is_vulnerable(version):
    if version.startswith("OpenSSH_"):
        version_num = version.split('_')[1].split()[0]
        try:
            parsed_version = parse_version(version_num.replace("p", "."))
        except InvalidVersion:
            return False, None
        if parsed_version < parse_version("2.3.0"):
            return True, "CVE-2001-0817"
        if parsed_version < parse_version("3.1"):
            return True, "CVE-2002-0083:"
        if parsed_version < parse_version("3.7.1.2"):
            return True, "CVE-2003-0190"
        if parsed_version < parse_version("4.4"):
            return True, "CVE-2006-5051, CVE-2008-4109"
        if parse_version("5.0") <= parsed_version < parse_version("5.0.2"):
            return True, "CVE-2008-5161"
        if parse_version("5.6") <= parsed_version < parse_version("7.9.1"):
            return True, "CVE-2019-6111"
        if parse_version("5.4") <= parsed_version < parse_version("7.1.1"):
            return True, "CVE-2016-0777"
        if parse_version("6.0") <= parsed_version < parse_version("6.0.2"):
            return True, "CVE-2012-0816"
        if parse_version("6.1") <= parsed_version < parse_version("6.1.2"):
            return True, "CVE-2012-0814"
        if parse_version("6.2") <= parsed_version < parse_version("6.2.3"):
            return True, "CVE-2013-4548"
        if parse_version("6.6") <= parsed_version < parse_version("6.6.2"):
            return True, "CVE-2014-2532"
        if parse_version("6.8") <= parsed_version < parse_version("6.9.1"):
            return True, "CVE-2015-5600"
        if parse_version("6.8") <= parsed_version < parse_version("6.8.2"):
            return True, "CVE-2015-6563"
        if parse_version("7.0") <= parsed_version < parse_version("7.0.2"):
            return True, "CVE-2015-6564"
        if parse_version("7.1") <= parsed_version < parse_version("7.1.3"):
            return True, "CVE-2016-3115"
        if parse_version("7.2") <= parsed_version < parse_version("7.2.3"):
            return True, "CVE-2016-6210"
        if parse_version("7.2") <= parsed_version < parse_version("7.2.1"):
            return True, "CVE-2016-10009"
        if parse_version("6.9") <= parsed_version < parse_version("6.9.2"):
            return True, "CVE-2016-10012"
        if parse_version("7.7") <= parsed_version < parse_version("7.7.1"):
            return True, "CVE-2018-15473"
        if parse_version("8.5") <= parsed_version < parse_version("9.8"):
            return True, "CVE-2024-6387"
    return False, None


vulnerable_ips = []


def get_ssh_version(ip, port):
    try:
        sock = socket.create_connection((ip, port), timeout=5)
        sock.sendall(b'\x00')
        response = sock.recv(1024).decode().strip()
        sock.close()
        if response.startswith("SSH-2.0-OpenSSH"):
            version_info = response.split('-')[2]
            if "OpenSSH_" in version_info:
                version = version_info.split('_')[1]
                return version
            else:
                return "no version"
        return "Invalid SSH identification string."
    except:
        pass


def generate_ipv4():
    octets = [str(random.randint(0, 255)) for _ in range(4)]
    ipv4 = ".".join(octets)
    return ipv4


def test_host():
    while True:
        target = generate_ipv4()
        if "://" in target:
            target = target.split("://")[1]
        
        target = target.rstrip('/')

        if ":" in target:
            ip, port = target.split(":")
            try:
                port = int(port)
            except ValueError:
                print_message('error', f"Invalid port in target {target}")
                return
        else:
            ip = target
            port = 22

        version = get_ssh_version(ip, port)
        if version:
            message = f"OpenSSH version {version} {ip}:{port}"
            is_vuln, cve_number = is_vulnerable(f"OpenSSH_{version}")
            if is_vuln:
                vuln_message = f"{cve_number} OpenSSH version {version} {ip}:{port}"
                print_message('vulnerable', vuln_message)
                vulnerable_ips.append(target)
            elif version == "Invalid SSH identification string.":
                message = f"{version} {ip}:{port}"
            else:
                print_message('ok', message)


def worker(queue):
    while not queue.empty():
        target = queue.get()
        test_host(target)
        queue.task_done()


def main():
    for thrs_amount in range(200):
        Thread(target=test_host).start()


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print_message('error', "Scanning interrupted by user.")
        sys.exit(1)
